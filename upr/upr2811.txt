Структура от данни, която работи над стринг
1) add(string)
2) search(string)
3) delete (string)
|string|<m

s masiv - 1) O(1), 2) O(n.m)

s dyrvo - 1) O(m*logn) 2) O(m*logn)

----------------------------------------------------------------------

префиксно дърво/Trie
рилича на автомат, буквите са по ребрата
пак имаме дърво - не е задължително да е двоично
по върховете има някакви лейбъли
думата в ноуда е всъщност пътя от корена до този връх
коренът отговоря на празната дума

- трябва да имаме константен размер на азбуката, всяка буква се съдържа не повече 
от веднъж на определено ниво
- за всеки връх трябва да имаме булев флаг, който ни казва дали това е краят на дума
(за да знаем кои дунми реално са вкарани в дървото)

1) add(string) (O(m))
2) search(string) (O(m))
3) delete (string) (O(m))
4) startWith(prefix) (O(m))

памет - O(sizeAlphabet*n*m)
n - брой думи
-------------------------------------------------------------------------
Имаме кореново дърво - нито двоично, нито наредено
q<=10^5 заявки
n<=10^5
k<=10^5

ANCESTOR(x,k) кой е к-тия родител на x - това е заявката

- лесен начин, подред да тръгнем по заявките и да се връщаме нагоре